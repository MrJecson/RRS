//-----------------------------------------------------------------------------
//
//      Абстрактный класс для блоков с кнопками или изображениями.
//      (c) РГУПС, ВЖД 03/03/2017
//      Разработал: Ковшиков С. В.
//
//-----------------------------------------------------------------------------
/*!
 *  \file
 *  \brief Абстрактный класс для блоков с кнопками или изображениями
 *  \copyright РГУПС, ВЖД
 *  \author Ковшиков С. В.
 *  \date 03/03/2017
 */

#include "abstract-block.h"


//-----------------------------------------------------------------------------
// КОНСТРУКТОР
//-----------------------------------------------------------------------------
AbstractBlock::AbstractBlock(QRect geo, QWidget *parent) : QLabel(parent)
{
    this->setGeometry(geo);
    this->setFixedSize(geo.size());
    this->setAutoFillBackground(true);
}



//-----------------------------------------------------------------------------
// ДЕСТРУКТОР
//-----------------------------------------------------------------------------
AbstractBlock::~AbstractBlock()
{

}



//-----------------------------------------------------------------------------
// Обработка нажатия кнопки
//-----------------------------------------------------------------------------
void AbstractBlock::receiveChildPressed(Local::ButtonId id)
{
    emit sendChildPressed(id);
}



//-----------------------------------------------------------------------------
// Обработка отпускания кнопки
//-----------------------------------------------------------------------------
void AbstractBlock::receiveChildReleased(Local::ButtonId id)
{
    emit sendChildReleased(id);
}



//-----------------------------------------------------------------------------
// Автоматическое выравнивание дочерних виджетов
//-----------------------------------------------------------------------------
void AbstractBlock::autoChildrenPos_(int pad, QPoint fixedPos)
{
//! ************************************************************
//! *    Входной параметр QPoint fixedPos предназначен для     *
//! * возможности жёстко задать координаты положения виджетов. *
//! *  Если подать ОТРИЦАТЕЛЬНОЕ число на X или Y, то жесткое  *
//! *         положение по данной оси ОТКЛЮЧАЕТСЯ.             *
//! ************************************************************

    // Указатель для работы с дочерними виджетами в цикле
    QWidget* bufWidget;

    // Выходим, если на блоке нет дочерних виджетов
    if (this->children().count() == 0)
        return;

    // Список дочерних виджетов
    QObjectList objList = this->children();

    // lp - left padding отступ от левой стороны
    int lp = 0;

    //tp - top padding отступ сверху
    int tp = 0;

    //pd - расстояние между дочерними элементами
    int pd = pad * (objList.count() - 1);

    // sumSize - суммарная ширина предыдущих кнопок
    int sumSize = 0;

    if (this->width() >= height())  // Если блок горизонтальрый W >= H
    {
        if (fixedPos.x() < 0) // Если на X подано ОТР. число
        {
            // Отступ по оси X с учетом суммарной ширины дочерних виджетов
            lp = (this->width() - (getSumChildrenLength_(WIDTH) + pd)) / 2;
        }
        else // Если на X подано число >= 0
        {
            // Отступ по оси X берется из входного параметра
            lp = fixedPos.x();
        }

        if (fixedPos.y() < 0) // Если на Y подано ОТР. число
        {
            // Отступ по оси Y с учетом высоты первого виджета
            tp = (this->height() -
                      qobject_cast<QWidget*>(objList.at(0))->height()) / 2;
        }
        else // Если на Y подано число > 0
        {
            // Отступ по оси Y берется из входного параметра
            tp = fixedPos.y();
        }

        // Заносим значение оступа по X в суммарную ширину
        sumSize = lp;

        for (int i = 0; i < objList.count(); i++)
        {
            // Преобразуем QObject в QWidget (т.к. в objList всё QObject)
            bufWidget = qobject_cast<QWidget *>(objList.at(i));
            // Перемещаем объект
            bufWidget->move(sumSize, tp);
            // Добавляем ширину виджета в суммарную ширину
            sumSize += bufWidget->width() + pad;
        }
    }
    else // Если блок вертикальный W < H
    {
        if (fixedPos.x() < 0) // Если на X подано ОТР. число
        {
            // Отступ по X с учетом ширины первого виджета
            lp = (this->width() -
                  qobject_cast<QWidget*>(objList.at(0))->width()) / 2;
        }
        else // Есл на X подано число >0
        {
            // Отступ по оси X берется из входного параметра
            lp = fixedPos.x();
        }

        if (fixedPos.y() < 0) // Если на Y подано ОТР. число
        {
            // Отступ по оси Y с учетом суммарной высоты дочерних виджетов
            tp = (this->height() - (getSumChildrenLength_(HEIGHT) + pd)) / 2;
        }
        else
        {
            // Оступ по оси Y берется из входного параметра
            tp = fixedPos.y();
        }

        // Заносим значение оступа по Y в суммарную высоту
        sumSize = tp;

        for (int i = 0; i < objList.count(); i++)
        {
            // Преобразуем QObject в QWidget (т.к. в objList всё QObject)
            bufWidget = qobject_cast<QWidget *>(objList.at(i));
            // Перемещаем объект
            bufWidget->move(lp, sumSize);
            // Добавляем высоту виджета в суммарную высоту
            sumSize += bufWidget->height() + pad;
        }
    }
}



//-----------------------------------------------------------------------------
// Вычисление суммарной ширины дочерних виджетов
//-----------------------------------------------------------------------------
int AbstractBlock::getSumChildrenLength_(Property prop)
{
    int bufLength = 0; // Суммарная ширина/высота

    // Список дочерних виджетов
    QObjectList objList = this->children();

    if (objList.count() != 0) // Если виджеты есть!
    {
        if (prop == WIDTH)
        {
            for (int i = 0; i < objList.count(); i++)
            {
                // Вычисляем суммартую ширину дочерних виджетов
                bufLength += qobject_cast<QWidget*>(objList.at(i))->width();
            }
        }
        else if (prop == HEIGHT)
        {
            for (int i = 0; i < objList.count(); i++)
            {
                // Вычисляем суммартую высоту дочерних виджетов
                bufLength += qobject_cast<QWidget*>(objList.at(i))->height();
            }
        }
    }
    // Возвращаем суммарную ширину/высоту дочерних виджетов
    return bufLength;
}
