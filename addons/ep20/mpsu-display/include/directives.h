//17/01/2018
#ifndef DIRECTIVES_H
#define DIRECTIVES_H

#include <cmath>
#include <qglobal.h>

/*
 * Я ленивый, поэтому сделал эти менее многословные директивы и касты.
 * P.S. KSV
 */


//-----------------------------------------------------------------------------
// Вывод отладочного текста без пробелов между словами
//-----------------------------------------------------------------------------
#ifndef DEB
    #define DEB() qDebug().nospace()
#else
    #error DEB() is defined already somewhere
#endif



//-----------------------------------------------------------------------------
// Приведение QString к QString.toStdString().c_str()
//-----------------------------------------------------------------------------
#ifndef C_STR
    #define C_STR(x) x.toStdString().c_str()
#else
    #error C_STR() is defined already somewhere
#endif



//-----------------------------------------------------------------------------
// Ноль
//-----------------------------------------------------------------------------
#ifndef ZERO_EPS
    #define ZERO_EPS 0.00001
#else
    #error ZERO_EPS is defined already somewhere
#endif



//-----------------------------------------------------------------------------
// Макрос постоянно используемого формата QImage
//-----------------------------------------------------------------------------
#ifndef DEF_FORMAT
    #define DEF_FORMAT QImage::Format_ARGB32_Premultiplied
#else
    #error DEF_FORMAT is defined already somewhere
#endif



//-----------------------------------------------------------------------------
// Макрос преобразования числа в QString
//-----------------------------------------------------------------------------
#ifndef SNUM
    #define SNUM QString::number
#else
    #error SNUM is defined already somewhere
#endif



//-----------------------------------------------------------------------------
// Макрос преобразования числа в QString
//-----------------------------------------------------------------------------
#ifndef EVS2_VEC_MAX
    #define EVS2_VEC_MAX(vec) *std::max_element(vec.begin(), vec.end())
#else
    #error EVS2_VEC_MAX is defined already somewhere
#endif



//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
#ifndef EVS2_FILL
    #define EVS2_FILL(vec, value) std::fill(vec.begin(), vec.end(), value);
#else
    #error EVS2_FILL is defined already somewhere
#endif



//-----------------------------------------------------------------------------
// Проверка на "близкость" к нулю
//-----------------------------------------------------------------------------
inline bool is_zero(double _v)
{
    return fabs(0.0 - _v) < ZERO_EPS; // ЧТО Я ТУТ ДЕЛАЮ???
}



//-----------------------------------------------------------------------------
// Сравнение двух вещественных чисел
//-----------------------------------------------------------------------------
inline bool fequal(double _fst, double _scnd)
{
    return fabs(_fst - _scnd) < ZERO_EPS;
}



//-----------------------------------------------------------------------------
// Проверка на вхождение в пределы объема контейнера
//-----------------------------------------------------------------------------
template<typename T, typename Container>
inline bool inRange(T _val, Container _container)
{
    return _val >= 0 && _val < static_cast<T>(_container.size());
}



//-----------------------------------------------------------------------------
// "В пределах" проверка на включительное вхождение между _left и _right
//-----------------------------------------------------------------------------
template<typename T>
inline bool inside(T _val, T _left, T _right)
{
    return _val >= _left && _val <= _right;
}


//-----------------------------------------------------------------------------
// "Между" проверка на исключительное вхождение между _left и _left
//-----------------------------------------------------------------------------
template<typename T>
inline bool between(T _val, T _left, T _right)
{
    return _val > _left && _val < _right;
}



//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
inline int pow2(int pow)
{
    int tmp = 1;
    while (pow)
    {
        tmp *= 2;
        --pow;
    }

    return tmp;
}



//-----------------------------------------------------------------------------
// Приведение одного указателя к другому. Как reinterpret_cast, но безопаснее.
// Проверяет, действительно ли это указатели во время компиляции
// Слегка опасное, но иногда нужное занятие.
//-----------------------------------------------------------------------------
template<typename T>
inline void ptr_cast(T &_dest, void* _src)
{
    _dest = static_cast<T>(_src);
}



//-----------------------------------------------------------------------------
// Приведение подходящего типа к типу qreal
//-----------------------------------------------------------------------------
template <typename T>
inline qreal qreal_cast(T _src)
{
    return static_cast<qreal>(_src);
}



//-----------------------------------------------------------------------------
// Приведение подходящего типа к типу qreal
//-----------------------------------------------------------------------------
template <typename T>
inline double double_cast(T _src)
{
    return static_cast<double>(_src);
}



template <typename T>
inline int int_cast(T _src)
{
    return static_cast<int>(_src);
}

#endif // DIRECTIVES_H
